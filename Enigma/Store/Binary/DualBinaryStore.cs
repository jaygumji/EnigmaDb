using Enigma.IO;
using Enigma.Store.Binary;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Enigma.Threading;

namespace Enigma.Store.Binary
{
    public class DualBinaryStore : IDualBinaryStore, IDisposable
    {

        private readonly IWriteStream _writeLeftStream;
        private readonly IWriteStream _writeRightStream;
        private readonly IWriteStream _writeHeaderStream;
        private readonly IStreamProvider _provider;

        private long _leftOffset;
        private long _rightOffset;

        private long _lastFlushedLeftOffset;
        private long _lastFlushedRightOffset;

        private readonly long _start;
        private readonly long _maxLength;

        private readonly object _writeHeaderLock = new object();
        private readonly object _writeLeftLock = new object();
        private readonly object _writeRightLock = new object();
        private readonly ILock<long> _writeLeftOffsetLock = new Lock<long>();
        private readonly ILock<long> _writeRightOffsetLock = new Lock<long>();

        private readonly IBinaryStore _left;
        private readonly IBinaryStore _right;

        public DualBinaryStore(IStreamProvider provider, long start, long maxLength)
        {
            if (provider == null) throw new ArgumentNullException("provider");
            if (start < 0) throw new ArgumentException("start parameter must have a value equal or greater than 0");
            if (maxLength <= 0) throw new ArgumentException("maxLength parameter must have a value greater than 0");

            _provider = provider;
            _start = start;
            _maxLength = maxLength;

            _writeHeaderStream = provider.AcquireWriteStream();
            _writeLeftStream = provider.AcquireWriteStream();
            _writeRightStream = provider.AcquireWriteStream();

            _writeHeaderStream.Seek(start, SeekOrigin.Begin);
            if (_writeHeaderStream.Length > start)
            {
                using (var readStream = _provider.AcquireReadStream())
                {
                    readStream.Seek(start, SeekOrigin.Begin);
                    var headerBuffer = new byte[16];
                    readStream.Read(headerBuffer, 0, headerBuffer.Length);
                    _leftOffset = BitConverter.ToInt64(headerBuffer, 0);
                    _rightOffset = BitConverter.ToInt64(headerBuffer, 8);

                    // If the buffer was not generated by the store
                    if (_leftOffset <= 0) _leftOffset = 16;
                    if (_rightOffset <= 0) _rightOffset = maxLength;
                }

                _writeLeftStream.Seek(start + _leftOffset, SeekOrigin.Begin);
                _writeRightStream.Seek(start + _rightOffset, SeekOrigin.Begin);
            }
            else
            {
                _leftOffset = 16;
                _rightOffset = maxLength;

                var headerBuffer = BitConverter.GetBytes(_leftOffset);
                _writeHeaderStream.Write(headerBuffer, 0, headerBuffer.Length);
                headerBuffer = BitConverter.GetBytes(_rightOffset);
                _writeHeaderStream.Write(headerBuffer, 0, headerBuffer.Length);
                _writeHeaderStream.Seek(-16, SeekOrigin.Current);

                _writeRightStream.Seek(start + _leftOffset, SeekOrigin.Begin);
                var buffer = new byte[maxLength - _leftOffset];
                _writeRightStream.Write(buffer, 0, buffer.Length);
                _writeLeftStream.Seek(start + _leftOffset, SeekOrigin.Begin);
            }

            _lastFlushedLeftOffset = _leftOffset;
            _lastFlushedRightOffset = _rightOffset;

            _left = new LeftBinaryStoreSegment(this);
            _right = new RightBinaryStoreSegment(this);
        }

        private void UpdateLeftOffset()
        {
            var offsetBuffer = BitConverter.GetBytes(_leftOffset);
            lock (_writeHeaderLock)
            {
                _writeHeaderStream.Write(offsetBuffer, 0, offsetBuffer.Length);
                _writeHeaderStream.Seek(-8, SeekOrigin.Current);
            }
        }

        private void UpdateRightOffset()
        {
            var offsetBuffer = BitConverter.GetBytes(_rightOffset);
            lock (_writeHeaderLock)
            {
                _writeHeaderStream.Seek(8, SeekOrigin.Current);
                _writeHeaderStream.Write(offsetBuffer, 0, offsetBuffer.Length);
                _writeHeaderStream.Seek(-16, SeekOrigin.Current);
            }
        }

        private void EnsureRightFlushed(long offset)
        {
            if (offset >= _lastFlushedRightOffset) return;

            lock (_writeRightLock)
            {
                if (offset >= _lastFlushedRightOffset) return;

                _writeRightStream.FlushForced();
                // We must also make sure to clear the read buffer so it reads the new data
                _provider.ClearReadBuffers();
                _lastFlushedRightOffset = _rightOffset;
            }
        }

        private void EnsureLeftFlushed(long offset)
        {
            if (offset < _lastFlushedLeftOffset) return;

            lock (_writeLeftLock)
            {
                if (offset < _lastFlushedLeftOffset) return;

                _writeLeftStream.FlushForced();
                // We must also make sure to clear the read buffer so it reads the new data
                _provider.ClearReadBuffers();
                _lastFlushedLeftOffset = _leftOffset;
            }
        }

        public bool IsLeftEmpty { get { return _leftOffset == 16; } }
        public bool IsRightEmpty { get { return _rightOffset == _maxLength; } }

        public IBinaryStore Left { get { return _left; } }
        public IBinaryStore Right { get { return _right; } }

        public bool IsSpaceAvailable(long length)
        {
            var rightSizeUsed = _maxLength - _rightOffset;
            var leftSizeUsed = _leftOffset;

            return rightSizeUsed + leftSizeUsed + length <= _maxLength;
        }

        public void WriteLeft(long storeOffset, byte[] data)
        {
            using (_writeLeftOffsetLock.Enter(storeOffset)) {
                using (var writeStream = _provider.AcquireWriteStream()) {
                    writeStream.Seek(_start + storeOffset, SeekOrigin.Begin);
                    writeStream.Write(data, 0, data.Length);
                    if (_lastFlushedLeftOffset > storeOffset)
                        _lastFlushedLeftOffset = storeOffset - 1;
                }
            }
        }

        public void WriteRight(long storeOffset, byte[] data)
        {
            using (_writeRightOffsetLock.Enter(storeOffset)) {
                using (var writeStream = _provider.AcquireWriteStream()) {
                    writeStream.Seek(_start + storeOffset, SeekOrigin.Begin);
                    writeStream.Write(data, 0, data.Length);
                    if (_lastFlushedRightOffset > storeOffset)
                        _lastFlushedRightOffset = storeOffset - 1;
                }
            }
        }

        public bool TryWriteLeft(byte[] data, out long storeOffset)
        {
            lock (_writeLeftLock)
            {
                if (!IsSpaceAvailable(data.Length))
                {
                    storeOffset = 0;
                    return false;
                }

                storeOffset = _leftOffset;
                _writeLeftStream.Write(data, 0, data.Length);
                _writeLeftStream.Flush();
                _leftOffset += data.Length;
                UpdateLeftOffset();
                return true;
            }
        }

        public bool TryWriteRight(byte[] data, out long storeOffset)
        {
            lock (_writeRightLock)
            {
                if (!IsSpaceAvailable(data.Length))
                {
                    storeOffset = 0;
                    return false;
                }

                _writeRightStream.Seek(-data.Length, SeekOrigin.Current);
                _writeRightStream.Write(data, 0, data.Length);
                _writeRightStream.Flush();
                _rightOffset -= data.Length;
                _writeRightStream.Seek(-data.Length, SeekOrigin.Current);
                storeOffset = _rightOffset;

                UpdateRightOffset();
                return true;
            }
        }

        public byte[] ReadAllLeft(out long offset)
        {
            offset = 16;
            EnsureLeftFlushed(_leftOffset);

            if (IsLeftEmpty) return new byte[] { };

            var buffer = new byte[_leftOffset - offset];
            using (var readStream = _provider.AcquireReadStream())
            {
                readStream.Seek(_start + offset, SeekOrigin.Begin);
                readStream.Read(buffer, 0, buffer.Length);
            }
            return buffer;
        }

        public byte[] ReadAllRight(out long offset)
        {
            offset = _rightOffset;
            EnsureRightFlushed(offset);

            if (IsRightEmpty) return new byte[] { };

            var buffer = new byte[_maxLength - offset];
            using (var readStream = _provider.AcquireReadStream())
            {
                readStream.Seek(_start + offset, SeekOrigin.Begin);
                readStream.Read(buffer, 0, buffer.Length);
            }
            return buffer;
        }

        public byte[] ReadLeft(long storeOffset, long length)
        {
            EnsureLeftFlushed(storeOffset);

            var buffer = new byte[length];
            using (var readStream = _provider.AcquireReadStream())
            {
                readStream.Seek(_start + storeOffset, SeekOrigin.Begin);
                readStream.Read(buffer, 0, buffer.Length);
            }
            return buffer;
        }

        public byte[] ReadRight(long storeOffset, long length)
        {
            EnsureRightFlushed(storeOffset);

            var buffer = new byte[length];
            using (var readStream = _provider.AcquireReadStream())
            {
                readStream.Seek(_start + storeOffset, SeekOrigin.Begin);
                readStream.Read(buffer, 0, buffer.Length);
            }
            return buffer;
        }

        public void Dispose()
        {
            _writeHeaderStream.Dispose();
            _writeLeftStream.Dispose();
            _writeRightStream.Dispose();

            _provider.Dispose();
        }


        public void TruncateRightTo(byte[] data)
        {
            lock (_writeRightStream)
            {
                _rightOffset = _maxLength - data.Length;
                _writeRightStream.Seek(_start + _rightOffset, SeekOrigin.Begin);
                _writeRightStream.Write(data, 0, data.Length);
                _writeRightStream.Seek(-data.Length, SeekOrigin.Current);
                UpdateRightOffset();
                _lastFlushedRightOffset = _maxLength;
                EnsureRightFlushed(_rightOffset);
            }
        }

        public void TruncateLeftTo(byte[] data)
        {
            lock (_writeLeftStream)
            {
                _leftOffset = 16 + data.Length;
                _writeLeftStream.Seek(_start + 16, SeekOrigin.Begin);
                _writeLeftStream.Write(data, 0, data.Length);
                UpdateLeftOffset();
                _lastFlushedLeftOffset = 16;
                EnsureLeftFlushed(_leftOffset);
            }
        }
    }
}
